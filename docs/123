# 更精确的实际收益率计算（考虑买卖价差）
df['actual_ret'] = np.where(
    df['pred'] == 2,  # 买入信号
    (df['future_mid'] - df['ask_price']) / df['ask_price'],
    np.where(
        df['pred'] == 0,  # 卖出信号
        (df['bid_price'] - df['future_mid']) / df['bid_price'],
        0  # 持有信号收益为0
    )
)

def compute_prices(test_df, preds, latency=pd.Timedelta(milliseconds=50), confidences=np.linspace(1/3, 1, 10)):
    pred_df = pd.concat([test_df, preds], axis=1)
    conf_df = test_df.copy()
    for confidence in confidences:
        labels = pd.Series([1]*len(test_df.index), index=test_df.index, name=f'label_{round(confidence, 2)}', dtype=np.uint) # hold everything
        labels[preds.max(axis=1) > confidence] = np.argmax(preds.values, axis=1)[preds.max(axis=1) > confidence]
        conf_df = pd.concat([conf_df, labels], axis=1)

    df_temp = conf_df.copy()
    df_temp.index = df_temp.index - latency

    # Perform an asof merge to get the last price and amount at time timestamp + latency for each timestamp, direction backward to trade at the current market state after latency
    df_merged = pd.merge_asof(conf_df, df_temp[['bid_price', 'ask_price', 'bid_amount', 'ask_amount']], left_index=True, right_index=True, suffixes=('', '_future'), direction="backward")

    df_merged.drop(['ask_price', 'ask_amount', 'bid_price', 'bid_amount'], inplace=True, axis=1)
    return df_merged

test_df = pd.read_csv(file_paths[-1], usecols=['timestamp', 'ask_price', 'bid_price', 'ask_amount', 'bid_amount'], engine='pyarrow')
test_df['timestamp'] = pd.to_datetime(test_df['timestamp'], unit='us')
test_df.set_index('timestamp', inplace=True)

prices = compute_prices(test_df, preds)
prices




import pandas as pd
import numpy as np
from scipy.stats import spearmanr, pearsonr

def calculate_ic_rankic(prices_df):
    """
    计算IC和RankIC
    要求输入DataFrame包含：
    - pred_buy: 买入预测概率
    - pred_sell: 卖出预测概率  
    - future_price: 未来价格
    - current_price: 当前价格
    """
    # 计算实际收益率（考虑买卖价差）
    prices_df['actual_ret'] = (
        prices_df['ask_price_future'] / prices_df['bid_price'] - 1  # 假设以bid价卖出，ask价买回
    )
    df['actual_ret'] = df['actual_ret'] - 0.0005  # 单边手续费0.05%
    # 计算预测信号（买概率 - 卖概率）
    prices_df['pred_signal'] = prices_df['pred_buy'] - prices_df['pred_sell']
    
    # IC计算（Pearson）
    ic = pearsonr(prices_df['pred_signal'], prices_df['actual_ret'])[0]
    
    # RankIC计算（Spearman）
    rankic = spearmanr(prices_df['pred_signal'], prices_df['actual_ret']).correlation
    
    return ic, rankic

def enhanced_compute_prices(test_df, preds, latency=pd.Timedelta(milliseconds=50)):
    """
    优化后的价格计算函数
    返回包含预测概率和未来价格的数据
    """
    # 确保preds是概率矩阵
    assert preds.shape[1] == 3, "preds应为3列矩阵[卖, 持有, 买概率]"
    
    # 合并预测概率
    pred_df = pd.DataFrame(
        preds, 
        columns=['pred_sell', 'pred_hold', 'pred_buy'],
        index=test_df.index
    )
    merged = pd.concat([test_df, pred_df], axis=1)
    
    # 获取未来价格（考虑延迟）
    future_prices = merged[['bid_price', 'ask_price']].copy()
    future_prices.index = future_prices.index + latency
    
    # 合并未来数据
    result = pd.merge_asof(
        merged.sort_index(),
        future_prices.sort_index(),
        left_index=True,
        right_index=True,
        suffixes=('', '_future'),
        direction='forward'  # 取未来最近的价格
    )
    
    return result.dropna()

# 使用示例
test_df = pd.read_csv(file_paths[-1], 
                     usecols=['timestamp', 'bid_price', 'ask_price'],
                     engine='pyarrow')
test_df['timestamp'] = pd.to_datetime(test_df['timestamp'], unit='us')
test_df.set_index('timestamp', inplace=True)

# 假设preds是模型输出的概率矩阵
preds = np.random.dirichlet([1,1,1], size=len(test_df))  # 模拟预测概率

# 生成增强数据
prices_df = enhanced_compute_prices(test_df, preds)

# 计算IC和RankIC
ic, rankic = calculate_ic_rankic(prices_df)
print(f"IC: {ic:.4f}, RankIC: {rankic:.4f}")




def action_specific_ic(df):
    """按动作类型计算IC"""
    results = {}
    for action, col in [('Sell', 'pred_sell'), ('Buy', 'pred_buy')]:
        subset = df[df[col] > 0.5]  # 取高置信度样本
        if len(subset) > 10:
            ic = pearsonr(subset[col], subset['actual_ret'])[0]
            rankic = spearmanr(subset[col], subset['actual_ret']).correlation
            results[action] = (ic, rankic)
    return results

action_ics = action_specific_ic(prices_df)
for action, (ic, rankic) in action_ics.items():
    print(f"{action}信号 IC: {ic:.4f}, RankIC: {rankic:.4f}")





import numpy as np
import pandas as pd
from scipy.stats import pearsonr, spearmanr

def calculate_performance_metrics(y_true, y_pred):
    """
    计算预测收益率与实际收益率的IC和RankIC
    
    参数:
        y_true: 实际收益率数组
        y_pred: 预测收益率数组
        
    返回:
        dict: 包含各项评估指标
    """
    # 确保输入为numpy数组并去除NaN
    y_true = np.asarray(y_true)
    y_pred = np.asarray(y_pred)
    mask = ~np.isnan(y_true) & ~np.isnan(y_pred)
    y_true = y_true[mask]
    y_pred = y_pred[mask]
    
    if len(y_true) == 0:
        raise ValueError("去除NaN后没有有效数据")
    
    # 计算IC（Pearson相关系数）
    ic, ic_pvalue = pearsonr(y_pred, y_true)
    
    # 计算RankIC（Spearman相关系数）
    rankic, rankic_pvalue = spearmanr(y_pred, y_true)
    
    # 计算IR（信息比率）
    ir = ic / np.std(y_pred)
    
    # 计算预测方向准确性
    direction_accuracy = np.mean(np.sign(y_pred) == np.sign(y_true))
    
    return {
        'IC': ic,
        'IC_pvalue': ic_pvalue,
        'RankIC': rankic,
        'RankIC_pvalue': rankic_pvalue,
        'IR': ir,
        'Direction_Accuracy': direction_accuracy,
        'N': len(y_true)
    }

def evaluate_on_test_set(test_df, model, feature_columns, target_column='future_ret'):
    """
    在测试集上评估模型预测收益率的性能
    
    参数:
        test_df: 测试集DataFrame
        model: 训练好的回归模型
        feature_columns: 特征列名列表
        target_column: 目标收益率列名
        
    返回:
        dict: 包含各项评估指标
    """
    # 准备测试数据
    X_test = test_df[feature_columns]
    y_test = test_df[target_column]
    
    # 预测收益率
    y_pred = model.predict(X_test)
    
    # 计算评估指标
    metrics = calculate_performance_metrics(y_test, y_pred)
    
    return metrics

# 示例使用方式
if __name__ == "__main__":
    # 假设已有测试数据和训练好的模型
    from sklearn.ensemble import RandomForestRegressor
    
    # 模拟数据
    np.random.seed(42)
    test_data = pd.DataFrame({
        'feature1': np.random.normal(0, 1, 1000),
        'feature2': np.random.normal(0, 1, 1000),
        'future_ret': np.random.normal(0, 0.01, 1000)
    })
    
    # 添加一些相关性（模拟预测能力）
    test_data['future_ret'] += 0.005 * test_data['feature1']
    
    # 训练简单模型
    model = RandomForestRegressor()
    model.fit(test_data[['feature1', 'feature2']], test_data['future_ret'])
    
    # 评估
    metrics = evaluate_on_test_set(
        test_df=test_data,
        model=model,
        feature_columns=['feature1', 'feature2']
    )
    
    # 打印结果
    print("测试集表现评估:")
    print(f"IC: {metrics['IC']:.4f} (p={metrics['IC_pvalue']:.3f})")
    print(f"RankIC: {metrics['RankIC']:.4f} (p={metrics['RankIC_pvalue']:.3f})")
    print(f"信息比率(IR): {metrics['IR']:.4f}")
    print(f"方向准确性: {metrics['Direction_Accuracy']:.2%}")
    print(f"有效样本数: {metrics['N']}")
