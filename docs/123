# 更精确的实际收益率计算（考虑买卖价差）
df['actual_ret'] = np.where(
    df['pred'] == 2,  # 买入信号
    (df['future_mid'] - df['ask_price']) / df['ask_price'],
    np.where(
        df['pred'] == 0,  # 卖出信号
        (df['bid_price'] - df['future_mid']) / df['bid_price'],
        0  # 持有信号收益为0
    )
)

def compute_prices(test_df, preds, latency=pd.Timedelta(milliseconds=50), confidences=np.linspace(1/3, 1, 10)):
    pred_df = pd.concat([test_df, preds], axis=1)
    conf_df = test_df.copy()
    for confidence in confidences:
        labels = pd.Series([1]*len(test_df.index), index=test_df.index, name=f'label_{round(confidence, 2)}', dtype=np.uint) # hold everything
        labels[preds.max(axis=1) > confidence] = np.argmax(preds.values, axis=1)[preds.max(axis=1) > confidence]
        conf_df = pd.concat([conf_df, labels], axis=1)

    df_temp = conf_df.copy()
    df_temp.index = df_temp.index - latency

    # Perform an asof merge to get the last price and amount at time timestamp + latency for each timestamp, direction backward to trade at the current market state after latency
    df_merged = pd.merge_asof(conf_df, df_temp[['bid_price', 'ask_price', 'bid_amount', 'ask_amount']], left_index=True, right_index=True, suffixes=('', '_future'), direction="backward")

    df_merged.drop(['ask_price', 'ask_amount', 'bid_price', 'bid_amount'], inplace=True, axis=1)
    return df_merged

test_df = pd.read_csv(file_paths[-1], usecols=['timestamp', 'ask_price', 'bid_price', 'ask_amount', 'bid_amount'], engine='pyarrow')
test_df['timestamp'] = pd.to_datetime(test_df['timestamp'], unit='us')
test_df.set_index('timestamp', inplace=True)

prices = compute_prices(test_df, preds)
prices




import pandas as pd
import numpy as np
from scipy.stats import spearmanr, pearsonr

def calculate_ic_rankic(prices_df):
    """
    计算IC和RankIC
    要求输入DataFrame包含：
    - pred_buy: 买入预测概率
    - pred_sell: 卖出预测概率  
    - future_price: 未来价格
    - current_price: 当前价格
    """
    # 计算实际收益率（考虑买卖价差）
    prices_df['actual_ret'] = (
        prices_df['ask_price_future'] / prices_df['bid_price'] - 1  # 假设以bid价卖出，ask价买回
    )
    df['actual_ret'] = df['actual_ret'] - 0.0005  # 单边手续费0.05%
    # 计算预测信号（买概率 - 卖概率）
    prices_df['pred_signal'] = prices_df['pred_buy'] - prices_df['pred_sell']
    
    # IC计算（Pearson）
    ic = pearsonr(prices_df['pred_signal'], prices_df['actual_ret'])[0]
    
    # RankIC计算（Spearman）
    rankic = spearmanr(prices_df['pred_signal'], prices_df['actual_ret']).correlation
    
    return ic, rankic

def enhanced_compute_prices(test_df, preds, latency=pd.Timedelta(milliseconds=50)):
    """
    优化后的价格计算函数
    返回包含预测概率和未来价格的数据
    """
    # 确保preds是概率矩阵
    assert preds.shape[1] == 3, "preds应为3列矩阵[卖, 持有, 买概率]"
    
    # 合并预测概率
    pred_df = pd.DataFrame(
        preds, 
        columns=['pred_sell', 'pred_hold', 'pred_buy'],
        index=test_df.index
    )
    merged = pd.concat([test_df, pred_df], axis=1)
    
    # 获取未来价格（考虑延迟）
    future_prices = merged[['bid_price', 'ask_price']].copy()
    future_prices.index = future_prices.index + latency
    
    # 合并未来数据
    result = pd.merge_asof(
        merged.sort_index(),
        future_prices.sort_index(),
        left_index=True,
        right_index=True,
        suffixes=('', '_future'),
        direction='forward'  # 取未来最近的价格
    )
    
    return result.dropna()

# 使用示例
test_df = pd.read_csv(file_paths[-1], 
                     usecols=['timestamp', 'bid_price', 'ask_price'],
                     engine='pyarrow')
test_df['timestamp'] = pd.to_datetime(test_df['timestamp'], unit='us')
test_df.set_index('timestamp', inplace=True)

# 假设preds是模型输出的概率矩阵
preds = np.random.dirichlet([1,1,1], size=len(test_df))  # 模拟预测概率

# 生成增强数据
prices_df = enhanced_compute_prices(test_df, preds)

# 计算IC和RankIC
ic, rankic = calculate_ic_rankic(prices_df)
print(f"IC: {ic:.4f}, RankIC: {rankic:.4f}")
