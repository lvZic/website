# 更精确的实际收益率计算（考虑买卖价差）
df['actual_ret'] = np.where(
    df['pred'] == 2,  # 买入信号
    (df['future_mid'] - df['ask_price']) / df['ask_price'],
    np.where(
        df['pred'] == 0,  # 卖出信号
        (df['bid_price'] - df['future_mid']) / df['bid_price'],
        0  # 持有信号收益为0
    )
)

def compute_prices(test_df, preds, latency=pd.Timedelta(milliseconds=50), confidences=np.linspace(1/3, 1, 10)):
    pred_df = pd.concat([test_df, preds], axis=1)
    conf_df = test_df.copy()
    for confidence in confidences:
        labels = pd.Series([1]*len(test_df.index), index=test_df.index, name=f'label_{round(confidence, 2)}', dtype=np.uint) # hold everything
        labels[preds.max(axis=1) > confidence] = np.argmax(preds.values, axis=1)[preds.max(axis=1) > confidence]
        conf_df = pd.concat([conf_df, labels], axis=1)

    df_temp = conf_df.copy()
    df_temp.index = df_temp.index - latency

    # Perform an asof merge to get the last price and amount at time timestamp + latency for each timestamp, direction backward to trade at the current market state after latency
    df_merged = pd.merge_asof(conf_df, df_temp[['bid_price', 'ask_price', 'bid_amount', 'ask_amount']], left_index=True, right_index=True, suffixes=('', '_future'), direction="backward")

    df_merged.drop(['ask_price', 'ask_amount', 'bid_price', 'bid_amount'], inplace=True, axis=1)
    return df_merged

test_df = pd.read_csv(file_paths[-1], usecols=['timestamp', 'ask_price', 'bid_price', 'ask_amount', 'bid_amount'], engine='pyarrow')
test_df['timestamp'] = pd.to_datetime(test_df['timestamp'], unit='us')
test_df.set_index('timestamp', inplace=True)

prices = compute_prices(test_df, preds)
prices
